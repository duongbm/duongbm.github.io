[ { "title": "Python Decorators and Closures", "url": "/posts/python-decorators-and-closures/", "categories": "", "tags": "", "date": "2021-11-14 22:00:00 +0700", "snippet": "Decorator 101 Decorator là 1 callable object có argument là 1 function.(function này gọi là decorated function)def deco(func): def inner(): print(&#39;run inner()&#39;) func() return inner@deco # -&amp;gt; decorator funcdef target(): # -&amp;gt; decorated func print(&#39;run target()&#39;)&amp;gt;&amp;gt;&amp;gt; target()... &#39;run inner()&#39;... &#39;run target()&#39; Decorator được execute ngay sau khi decorated được define. (hay còn gọi là import time)Closures Là function có thể giữ lại được các binding variables được define trong chính nó cho các lần call tiếp theo.def calculate_avg(): series = [] def avenger(new_value): series.append(new_value) total = sum(series) return total / len(series) return avenger&amp;gt;&amp;gt;&amp;gt; avg = calculate_avg()&amp;gt;&amp;gt;&amp;gt; avg(10) ... 10&amp;gt;&amp;gt;&amp;gt; avg(20)... 20Bình thường sau khi call các function thì các local variable trong function đó sẽ được khởi tạo lại từ đầu cho các lần gọi tiếp. Tuy nhiên với closure, thì ngược lại, các biến local variale vẫn được lưu trữ và sử dụng lại với các lần gọi tiếp theo.SingleDispatch decoratorfrom functools import singledispatchdef greeting(obj: object) -&amp;gt; str: return &#39;greeting&#39;@greeting.registerdef _(message: str) -&amp;gt; str: return &#39;hello &#39; + message@greeting.registerdef _(messages: list) -&amp;gt; str: return &#39;hello &#39; + &#39;,&#39;.join(messages)&amp;gt;&amp;gt;&amp;gt; greeting(&#39;Mr.Dungo&#39;)... hello Mr.Dungo&amp;gt;&amp;gt;&amp;gt; greeting([&#39;Dungo&#39;, &#39;Gango&#39;])... hello Dungo, Gango" }, { "title": "Function trong python", "url": "/posts/python-basic-function/", "categories": "", "tags": "", "date": "2021-11-13 22:00:00 +0700", "snippet": "Function là objects&amp;gt;&amp;gt;&amp;gt; def factorial(n):... &quot;&quot;&quot;return n!&quot;&quot;&quot;... return 1 if n &amp;lt; 2 else n * factorial(n - 1)...&amp;gt;&amp;gt;&amp;gt; factorial.__doc__ # __doc__ là 1 attribute của object factorial&#39;return n!&#39;&amp;gt;&amp;gt;&amp;gt; type(factorial) # factorial là 1 object của function class&amp;lt;class &#39;function&#39;&amp;gt; Higher-Order function Là function nhận argument là 1 function khác hoặc return 1 function thay cho các biến bình thường.def say_hello(): return &#39;Hello&#39;def greeting(func): # high-order print(func() + &#39; Mr.Dungo&#39;)&amp;gt;&amp;gt;&amp;gt; greeting(say_hello) # pass function as argument&#39;Hello Mr.Dungo&#39;Anonymous function Tức là những function khi khởi tạo sẽ không có name.reverse = lambda x: x[::-1] # anonymous function with lambda keyword is assigned to a variable&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3, 4, 5]&amp;gt;&amp;gt;&amp;gt; reverse(a)[5, 4, 3, 2, 1]Callable objects Là những object sử dụng () operator để thực thi.Có 9 loại callable object:1. User-defined functions Tạo với def hoặc lambda keyword2. Builtin function Ví dụ: len hoặc type3. Builtin method Ví dụ: dict.get hoặc list.append4. Methods Ví dụ: function được khai báo trong class5. Classes Ví dụ: khi khởi tạo 1 object6. Class instances Nếu __call__ được implement trong 1 class thì có thể dùng instance như function.7. Native coroutine function Ví dụ: async def8. Generator functions Ví dụ: function or method sử dụng yield9. Asynchronous generator function Ví dụ: async for&quot;&quot;&quot;Implement số 6&quot;&quot;&quot;import randomclass Dice: def __init__(self): self.dice = list(range(1,7)) def roll(self): random.shuffle(self.dice) return self.dice[0] def __call__(self): return self.roll() &amp;gt;&amp;gt;&amp;gt; dice = Dice()&amp;gt;&amp;gt;&amp;gt; dice.roll()... 5&amp;gt;&amp;gt;&amp;gt; dice()... 2 " } ]
